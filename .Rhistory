}
# what kind of dates
if(length(dts) > 1) {
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
n_days = length(dts)
message(paste("Extracting data for a sequential range of", n_days,  "dates"))
message(paste("with", max(days_back), "day(s) in antecedence"))
# output will be a list of datafames
out = vector("list", length = length(dts))
} else{
# only specifc dates
message(paste("Extracting data for", length(dts), "specific dates"))
message(paste("with", max(days_back), "day(s) in antecedence"))
dts = dts
# output will be a list of datafames
out = vector("list", length = length(dts))
}
} else{
# only one specific date
message(paste("Extracting data for one date:", dts, "\n",
"with", max(days_back), "day(s) in antecedence" ))
dts = dts
# output will be only one dataframe
out = data.frame()
}
# put the dates into a list as iterating over a vector loses class information
dts = as.list(dts)
dts
day = dts[[1]]
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
path_year_month = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
path_year_month
# open the file
ncin = ncdf4::nc_open(path_year_month)
ncin
dates = ncdf4::ncvar_get(ncin, "DATE")
dates
dunits = ncdf4::ncatt_get(ncin, "DATE", "units")
dunits
# convert the time variable
tustr = strsplit(dunits$value, " ")
tdstr = strsplit(unlist(tustr)[[3]], "-")
tmonth = as.integer(unlist(tdstr)[[2]])
tday = as.integer(unlist(tdstr)[[3]])
tyear = as.integer(unlist(tdstr)[[1]])
all_dates = chron::chron(dates, origin = c(tmonth, tday, tyear))
all_dates
class(ncin)
devtools::load_all()
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
dts
class(dts)
dts = dts[[1]]
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
library(bannerCommenter)
banner("WORK WITH NETCDF", snug=T, bandChar = "")
banner("WORK WITH NETCDF", snug=T, bandChar = "-")
devtools::load_all()
library(ncdf4.helpers)
st_crs(shape)
# read the precipitation values
precip_nc = ncvar_get(ncin, nc_var)
nc_var = "precipitation"
# read the precipitation values
precip_nc = ncvar_get(ncin, nc_var)
nc_var
precip_nc
dim(precip_nc)
# read the projection info
proj = nc.get.proj4.string(ncin)
# read the projection info
proj = nc.get.proj4.string(ncin, nc_var)
proj
epsgs = rgdal::make_EPSG()
head(epsgs)
epsgs %>% filter(str_detect(prj4, proj))
r("\\")
r"\\zs"
r"{\\zs}"
sprintf(r"%s", proj)
sprintf(r"{%s}", proj)
epsgs %>% filter(str_detect(prj4, sprintf(r"{%s}", proj)))
a = sprintf(r"{%s}", proj)
class(a)
proj
epsgs
dim(epsgs)
proj
t = raster(ncin)
library(raster)
t = raster(ncin)
ncin
raster(path_year_month)
t = raster(path_year_month)[[1]]
crs(t)
st_crs(t)
st_crs(t) == st_crs(shape)
crs(shape)
crs(r)
crs(r)t
crs(t)
shape
st_crs(shape)
crs(shape)
st_crs(shape)
st_crs(t)
crs(shape)
rgdal::showEPSG(proj)
rgdal::showEPSG(st_crs(shape))
s = crs(shape)
rgdal::showEPSG(st_crs(s))
s
class(s)
s = st_crs(shape)
proj4string(shape)
s
s$input
rgdal::showSRID(t)
t
rgdal::showEPSG(t)
crs_ras = crs(t)
crs_ras
class(crs_ras)
rgdal::showEPSG(crs_ras)
raster::crs(r)
r
t
raster::crs(t)
c = raster::crs(t)
c@projargs
rgdal::showEPSG(c@projargs)
rgdal::showEPSG(c)
st_crs(shape)
crs(shape)
a = crs(shape)
a@projargs
rgdal::showEPSG(a@projargs)
crs_nc = raster(path_year_month)[[1]] %>% crs(.)$projargs
crs_nc
raster(path_year_month)[[1]]
a = raster(path_year_month)[[1]]
a %>% crs()
a %>% crs()@projargs
b = a %>% crs()
attributes(b)
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes()
crs_nc
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% [[]]$projargs
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% [[$projargs
crs_shape = raster(path_year_month)[[1]]
stopifnot()
}
}
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% [["projargs"]]
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]]
crs_nc
crs_shape = crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]]
crs_shape
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]]
crs_shape = crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]]
stopifnot()
?stopifnot
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]]
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]]
crs_shape = crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]]
stopifnot("The CRS of the spatial object and the NetCDF are not equal" = crs_nc == crs_shape)
# if not equal to crs of sf object stop here!
crs_nc = suppressWarnings(raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]])
crs_nc = suppressWarnings(raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape = suppressWarnings(crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]])
stopifnot("The CRS of the spatial object and the NetCDF are not equal" = crs_nc == crs_shape)
st_crs(shape)
st_crs(shape) = crs_nc
?st_transform
st_transform(shape, crs_nc)
shape = st_transform(shape, crs_nc)
# if not equal to crs of sf object stop here!
crs_nc = suppressWarnings(raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape = suppressWarnings(crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]])
stopifnot("The CRS of the spatial object and the NetCDF are not equal" = crs_nc == crs_shape)
warning("The CRS of the spatial object and the NetCDF are not equal")
warning("The CRS of the spatial object and the NetCDF are not equal\n")
# if not equal to crs of sf object stop/reproject here!
crs_nc = suppressWarnings(raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape = suppressWarnings(crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]])
# if not equal, reproject the shape...
if(!crs_nc == crs_shape){
warning(sprintf("The CRS of the spatial object and the NetCDF are not equal\n
Reprojecting the shape to: %s", crs_nc))
}
shape = st_read(spatial.obj)
spatial.obj
shape = spatial.obj
class(shape)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
shape
s1 = shape[1,]
dim(s1)
s
s1
shape = s1
shape
plot(shape)
class(shape)
plot(shape)
plot(st_geometry(shape))
a = 1:3
a
for (i in a) {
print(i)
}
class(precip_nc)
sessionInfo()
devtools::load_all()
sessionInfo()
file.edit("DESCRIPTION")
usethis::use_package("dplyr")
usethis::use_package("s")
usethis::use_package("sf")
usethis::use_package("raster")
usethis::use_package("cron")
usethis::use_package("chron")
usethis::use_package("ncdf4")
usethis::use_package("ncdf4.helpers")
usethis::use_package("assertthat")
sessionInfo()
devtools::load_all()
sessionInfo()
?get_rainfall
devtools::load_all()
?get_rainfall
devtools::load_all()
devtools::load_all()
?get_rainfall
devtools::document()
?get_rainfall
devtools::document()
?get_rainfall
sptial.obj
spatial.obj
shape
shape = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_1.shp"
s = st_read(shape)
nrow(s)
shape = s[1,]
nrow(shape)
dts
dts = c(as.Date("2020-01-01"), as.Date("2012-01-01"))
dts = as.list(dts)
dts
# output will be only one dataframe
out = vector("list", length = length(dts))
out
names(out) = sapply(dts, name)
names(out) = sapply(dts, function(x) x)
out
sapply(dts, function(x) x)
dts
for (i in dts) {
print(i)
}
}
for (i in dts) {
print(i)
}
for (i in dts) {
print(i)
}
seq_along(out)
# name the output
for (i in seq_along(out)) {
names(out) == dts[[i]]
}
out
as.character(dts[[1]])
# name the output
for (i in seq_along(out)) {
names(out) == as.character(dts[[i]])
}
out
# name the output
for (i in seq_along(out)) {
print(as.character(dts[[i]]))
}
as.character(dts[[i]]) %>% str_replace(., "-", "")
as.character(dts[[i]]) %>% str_replace_all(., "-", "")
# name the output
for (i in seq_along(out)) {
n = as.character(dts[[i]]) %>% str_replace_all(., "-", "")
names(out)[[i]] = n
}
out
file.edit("notes/notes.R")
file.edit("notes/notes.Rmd")
devtools::load_all()
shape
dts
dts = c(as.date("2020-01-01"), as.Date("2021-02-02"))
dts = c(as.Date("2020-01-01"), as.Date("2021-02-02"))
dts = as.Date("2018-01-01")
dts
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
a = rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
a
devtools::load_all()
a = rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
devtools::load_all()
a = rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
a = rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
a
shape
devtools::load_all()
a = rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
a = rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
# if not equal to crs of sf object stop/reproject here!
crs_nc = suppressWarnings(ex_r %>% crs() %>% attributes() %>% .[["projargs"]])
# read an exmaple raster and create the empty grid --> do outside the loop
ex_r = raster(path_year_month)[[1]]
devtools::load_all()
devtools::load_all()
a = rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
a = rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
a = rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
data_path="\\\\projectdata.eurac.edu/projects/Proslide/PREC_GRIDS/"
spatial.obj = shape
nc_var = "precipitation"
days_back = 1:1
# verify its an object of type sf
assert_that(class(spatial.obj)[[1]] == "sf", msg="The spatial data is not of class sf")
# assert that dates are actually dates
assert_that(assertthat::is.date(dts), msg = "dts must be an object of type date")
# integer range of dates
assert_that(is.integer(days_back), msg = "The date range must be of type integer")
# get the geometry type of the sf object
gtype = st_geometry_type(spatial.obj, by_geometry = FALSE) %>% as.character()
if(!gtype=="POINT"){
gtype="poly"
}  else{
gtype="point"
}
# what kind of dates
# if we have more than one date than we will return a list of dataframes
if(length(dts) > 1) {
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
n_days = length(dts)
message(paste("Extracting data for a sequential range of", n_days,  "dates"))
message(paste("with", max(days_back), "day(s) in antecedence"))
# output will be a list of datafames
out = vector("list", length = length(dts))
} else{
# only specifc dates
message(paste("Extracting data for", length(dts), "specific dates"))
message(paste("with", max(days_back), "day(s) in antecedence"))
dts = dts
# output will be a list of datafames
out = vector("list", length = length(dts))
}
} else{
# only one specific date
message(paste("Extracting data for one date:", dts, "\n",
"with", max(days_back), "day(s) in antecedence" ))
dts = dts
# output will be only one dataframe
out = vector("list", length = length(dts))
}
# name the output
for (i in seq_along(out)) {
n = as.character(dts[[i]]) %>% str_replace_all(., "-", "")
names(out)[[i]] = n
}
##----------------------
##  WORK WITH NETCDF  --
##----------------------
# this assumes that the structure of the rainfall data will stay the same
# put the dates into a list as iterating over a vector loses class information..
dts = as.list(dts)
day = dts[[1]]
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
d
as.integer(d)
devtools::load_all()
a = rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
dts = as.Date("2018-01-12")
a = rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
day
out_rasters = c()
# name the output
for (i in seq_along(out)) {
n = as.character(dts[[i]]) %>% str_replace_all(., "-", "")
names(out)[[i]] = n
}
##----------------------
##  WORK WITH NETCDF  --
##----------------------
# this assumes that the structure of the rainfall data will stay the same
# put the dates into a list as iterating over a vector loses class information..
dts = as.list(dts)
y = format(dts[[1]], "%y")
y
y = format(dts[[1]], "%Y")
y
ex_path = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
ex_path
# example path
ex_path = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
# example raster
grd = raster(path_year_month)[[1]]
grd[] = NA
# if not equal to crs of sf object stop/reproject here!
crs_nc = suppressWarnings(grd %>% crs() %>% attributes() %>% .[["projargs"]])
# get one example raster
y = format(dts[[1]], "%Y")
m = format(dts[[1]], "%m")
d = format(dts[[1]], "%d")
# example path
ex_path = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
# example raster
grd = raster(path_year_month)[[1]]
# example raster
grd = raster(ex_path)[[1]]
grd
grd[] = NA
# if not equal to crs of sf object stop/reproject here!
crs_nc = suppressWarnings(grd %>% crs() %>% attributes() %>% .[["projargs"]])
crs_nc
crs_shape = suppressWarnings(crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape
# if not equal, reproject the shape...
if(!crs_nc == crs_shape){
warning(sprintf("The CRS of the spatial object and the NetCDF are not equal Reprojecting the shape to: %s", crs_nc))
shape = st_transform(shape, crs_nc)
}
day = dts[[1]]
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
path_year_month = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
day
days_back
day
class(day)
day - 5
days_back
days_back = 1:12
day
days_back = 1:14
max_day_back = day - days_back
max_day_back
max_day_back = min(day - days_back)
max_day_back
month_max_day_back = format(max_day_back, "%m")
month_max_day_back
current_month = format(day, "%m")
current_month
last_month_path = paste0(data_path, y_b, "/", "DAILYPCP_", y_b, formatC(m_b, flag = 0, width = 2), ".nc")
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
rainfallR::get_rainfall(spatial.obj = shape, dts=dts, days_back = 1:20)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts, days_back = 1:20)
rainfallR::get_rainfall(spatial.obj = shape, dts=dts, days_back = 1:2)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts, days_back = 1:2)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts, days_back = 1:2)
path = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_1.shp"
shape = st_read(path)
library(sf)
devtools::load_all()
path = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_1.shp"
shape = st_read(path)
