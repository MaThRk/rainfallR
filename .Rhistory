}  else{
gtype="point"
}
# for creating a sequence between two dates
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
}
# output will be a list of datafames
out = vector("list", length = length(dts))
# name the output
for (i in seq_along(out)) {
n = as.character(dts[[i]]) %>% str_replace_all(., "-", "")
names(out)[[i]] = n
}
library(stringr)
seqq = TRUE
nc_var = "precipitation"
days_back = 2
# get the geometry type of the sf object
gtype = st_geometry_type(spatial.obj, by_geometry = FALSE) %>% as.character()
if(!gtype=="POINT"){
gtype="poly"
}  else{
gtype="point"
}
# for creating a sequence between two dates
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
}
# output will be a list of datafames
out = vector("list", length = length(dts))
# name the output
for (i in seq_along(out)) {
n = as.character(dts[[i]]) %>% str_replace_all(., "-", "")
names(out)[[i]] = n
}
##----------------------
##  WORK WITH NETCDF  --
##----------------------
# this assumes that the structure of the rainfall data will stay the same
# put the dates into a list as iterating over a vector loses class information..
dts = as.list(dts)
# get one example raster
y = format(dts[[1]], "%Y")
m = format(dts[[1]], "%m")
d = format(dts[[1]], "%d")
# example path
ex_path = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
# example raster
grd = raster(ex_path)[[1]]
grd[] = NA
# if not equal to crs of sf object stop/reproject here!
crs_nc = suppressWarnings(grd %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape = suppressWarnings(crs(spatial.obj) %>% crs() %>% attributes() %>% .[["projargs"]])
# if not equal, reproject the shape...
if(!crs_nc == crs_shape){
warning(sprintf("The CRS of the spatial object and the NetCDF are not equal Reprojecting the shape to: %s", crs_nc))
spatial.obj = st_transform(spatial.obj, crs_nc)
}
day = dts[[1]]
# create counter
counter = 1
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
paths_to_data = get_nc_paths(data_path, day, days_back)
devtools::load_all()
# create the path to the data for one month
paths_to_data = get_nc_paths(data_path, day, days_back)
paths_to_data
message("Accessing these NetCDF-files: ", paths_to_data)
# if all the data we want comes from the same month
if(length(paths_to_data == 1)){
# open the file
ncin = ncdf4::nc_open(paths_to_data[[1]])
# get a character string of the dates
dates_nc = get_dates_ncdf(ncin, return_date_object=T)
raster_list = get_raster_list_one_month(day, days_back, dates_nc, paths_to_data)
} else{
# we need a loop in order to extract them
# if the back days reach into the last month..
# for each month
raster_list = get_raster_list_n_month(paths_to_data, day, days_back)
}
raster_list
# ectract the spatial data
day_data_frame = lapply(raster_list, function(x){
raster::extract(x, spatial.obj, sp=T) %>% st_as_sf()
})
day_data_frame
# make in one dataframe where each column is one date
b = bind_cols(day_data_frame)
geom = b %>% dplyr::select(matches("geom")) %>% pull(1)
b = b %>% dplyr::select(matches("^x")) %>%
rename_all(funs(stringr::str_replace_all(., pattern = "X", "")))
b[["geometry"]] = geom
b = st_as_sf(b)
b
# assign it to out
out[[counter]] = b
out
counter = counter + 1
counter
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
paths_to_data = get_nc_paths(data_path, day, days_back)
message("Accessing these NetCDF-files: ", paths_to_data)
# if all the data we want comes from the same month
if(length(paths_to_data == 1)){
# open the file
ncin = ncdf4::nc_open(paths_to_data[[1]])
# get a character string of the dates
dates_nc = get_dates_ncdf(ncin, return_date_object=T)
raster_list = get_raster_list_one_month(day, days_back, dates_nc, paths_to_data)
} else{
# we need a loop in order to extract them
# if the back days reach into the last month..
# for each month
raster_list = get_raster_list_n_month(paths_to_data, day, days_back)
}
day = dts[[Â²]]
day = dts[[2]]
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
paths_to_data = get_nc_paths(data_path, day, days_back)
message("Accessing these NetCDF-files: ", paths_to_data)
# if all the data we want comes from the same month
if(length(paths_to_data == 1)){
# open the file
ncin = ncdf4::nc_open(paths_to_data[[1]])
# get a character string of the dates
dates_nc = get_dates_ncdf(ncin, return_date_object=T)
raster_list = get_raster_list_one_month(day, days_back, dates_nc, paths_to_data)
} else{
# we need a loop in order to extract them
# if the back days reach into the last month..
# for each month
raster_list = get_raster_list_n_month(paths_to_data, day, days_back)
}
# ectract the spatial data
day_data_frame = lapply(raster_list, function(x){
raster::extract(x, spatial.obj, sp=T) %>% st_as_sf()
})
# make in one dataframe where each column is one date
b = bind_cols(day_data_frame)
geom = b %>% dplyr::select(matches("geom")) %>% pull(1)
b = b %>% dplyr::select(matches("^x")) %>%
rename_all(funs(stringr::str_replace_all(., pattern = "X", "")))
b[["geometry"]] = geom
b = st_as_sf(b)
# assign it to out
out[[counter]] = b
counter = counter + 1
out
return(out)
devtools::load_all()
res = get_rainfall(spatial.obj = spatial.obj, dts=dts)
res
names(res)
res[[1]]
path2 = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI5_1.shp"
spatial.obj = st_read(path2)
path2 = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_5.shp"
spatial.obj = st_read(path2)
?extract
fun=mean
spatial.obj
spatial.obj = spatial.obj[1,]
sptial.obj
spatial.obj
# ectract the spatial data
if(!is.null(fun)) {
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, sp = T) %>% st_as_sf()
})
} else{
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, fun = fun, sp = T) %>% st_as_sf()
})
}
fun
fun = "mean"
fun
# ectract the spatial data
if(!is.null(fun)) {
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, sp = T) %>% st_as_sf()
})
} else{
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, fun = fun, sp = T) %>% st_as_sf()
})
}
# ectract the spatial data
if(!is.null(fun)) {
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, sp = T) %>% st_as_sf()
})
} else{
message("using polygons and the function: ", fun)
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, fun = fun, sp = T) %>% st_as_sf()
})
}
# ectract the spatial data
if(!is.null(fun)) {
print("here")
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, sp = T) %>% st_as_sf()
})
} else{
message("using polygons and the function: ", fun)
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, fun = fun, sp = T) %>% st_as_sf()
})
}
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, sp = T) %>% st_as_sf()
})
day_data_frame = lapply(raster_list, function(x){
raster::extract(x, spatial.obj, sp=T) %>% st_as_sf()
})
raster_list
lapply(raster_list, function(x){
raster::extract(x, spatial.obj, sp=T) %>% st_as_sf()
})
day_data_frame = lapply(raster_list, function(x){
print(class(x))
raster::extract(x, spatial.obj, sp=T) %>% st_as_sf()
})
raster_list
raster::extract(raster_list[[1]], spatial.obj)
plot(spatial.obj)
raster::extract(raster_list[[1]], spatial.obj, fun=sum)
raster::extract(raster_list[[1]], spatial.obj, fun=,eam)
raster::extract(raster_list[[1]], spatial.obj, fun=mean)
raster::extract(raster_list[[1]], spatial.obj, fun="mean")
raster::extract(raster_list[[1]], spatial.obj, fun=mean)
day_data_frame = lapply(raster_list, function(x){
raster::extract(x, spatial.obj, sp=T) %>% st_as_sf()
day_data_frame = lapply(raster_list, function(x){
raster::extract(x, spatial.obj, sp=T) %>% st_as_sf()
})
day_data_frame = lapply(raster_list, function(x){
raster::extract(x, spatial.obj, sp=T) %>% st_as_sf()
})
raster::extract(x, spatial.obj, fun = fun, sp = T)
raster::extract(raster_list[[1]], spatial.obj, fun=mean) %>% st_as_sf()
raster::extract(raster_list[[1]], spatial.obj, fun=mean, sp=T) %>% st_as_sf()
day_data_frame = lapply(raster_list, function(x){
raster::extract(x, spatial.obj, sp=TRUE) %>% st_as_sf()
})
rm(list=ls())
devtools::load_all()
data_path="\\\\projectdata.eurac.edu/projects/Proslide/PREC_GRIDS/"
path = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_1.shp"
path2 = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_5.shp"
spatial.obj = st_read(path2)
dts = c(as.Date("2016-01-12"), as.Date("2016-01-14"))
# get the geometry type of the sf object
gtype = st_geometry_type(spatial.obj, by_geometry = FALSE) %>% as.character()
if(!gtype=="POINT"){
gtype="poly"
}  else{
gtype="point"
}
# for creating a sequence between two dates
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
}
nc_var = "precipitation"
seqq = TRUE
days_back = 2
# get the geometry type of the sf object
gtype = st_geometry_type(spatial.obj, by_geometry = FALSE) %>% as.character()
if(!gtype=="POINT"){
gtype="poly"
}  else{
gtype="point"
}
# for creating a sequence between two dates
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
}
# output will be a list of datafames
out = vector("list", length = length(dts))
# name the output
for (i in seq_along(out)) {
n = as.character(dts[[i]]) %>% str_replace_all(., "-", "")
names(out)[[i]] = n
}
##----------------------
##  WORK WITH NETCDF  --
##----------------------
# this assumes that the structure of the rainfall data will stay the same
# put the dates into a list as iterating over a vector loses class information..
dts = as.list(dts)
# get one example raster
y = format(dts[[1]], "%Y")
m = format(dts[[1]], "%m")
d = format(dts[[1]], "%d")
# example path
ex_path = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
# example raster
grd = raster(ex_path)[[1]]
grd[] = NA
# if not equal to crs of sf object stop/reproject here!
crs_nc = suppressWarnings(grd %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape = suppressWarnings(crs(spatial.obj) %>% crs() %>% attributes() %>% .[["projargs"]])
# if not equal, reproject the shape...
if(!crs_nc == crs_shape){
warning(sprintf("The CRS of the spatial object and the NetCDF are not equal Reprojecting the shape to: %s", crs_nc))
spatial.obj = st_transform(spatial.obj, crs_nc)
}
# for each day create a dataframe
counter = 1
day = dts[[1]]
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
paths_to_data = get_nc_paths(data_path, day, days_back)
message("Accessing these NetCDF-files: ", paths_to_data)
# open the file
ncin = ncdf4::nc_open(paths_to_data[[1]])
# get a character string of the dates
dates_nc = get_dates_ncdf(ncin, return_date_object=T)
raster_list = get_raster_list_one_month(day, days_back, dates_nc, paths_to_data)
day_data_frame = lapply(raster_list, function(x){
raster::extract(x, spatial.obj, sp=TRUE) %>% st_as_sf()
})
devtools::load_all()
raster_list = get_raster_list_one_month(day, days_back, dates_nc, paths_to_data)
day_data_frame = lapply(raster_list, function(x){
raster::extract(x, spatial.obj, sp=TRUE) %>% st_as_sf()
})
spatial.obj = spatial.obj[1:3, ]
spatial.obj
ex = raster::extract(raster_list[[1]], spatial.obj, sp=T, fun=mean)
ex
fun = mean
fun
fun = "mean"
as.expression(fun)
# ectract the spatial data
if(is.null(fun)) {
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, sp = T) %>% st_as_sf()
})
} else{
message("using polygons and the function: ", fun)
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, fun = mean, sp = T) %>% st_as_sf()
})
}
day_data
day_data_frame
# make in one dataframe where each column is one date
b = bind_cols(day_data_frame)
b
geom = b %>% dplyr::select(matches("geom")) %>% pull(1)
geom
b = b %>% dplyr::select(matches("^x")) %>%
rename_all(funs(stringr::str_replace_all(., pattern = "X", "")))
b
b[["geometry"]] = geom
b = st_as_sf(b)
b
# assign it to out
out[[counter]] = b
#' @export
get_rainfall = function(data_path="\\\\projectdata.eurac.edu/projects/Proslide/PREC_GRIDS/",
spatial.obj = NULL,
fun = NULL,
dts = NULL,
nc_var = "precipitation",
seqq = TRUE, # do you want all dates in this sequence or only specific dates?
days_back = 2){
# get the geometry type of the sf object
gtype = st_geometry_type(spatial.obj, by_geometry = FALSE) %>% as.character()
if(!gtype=="POINT"){
gtype="poly"
}  else{
gtype="point"
}
# for creating a sequence between two dates
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
}
# output will be a list of datafames
out = vector("list", length = length(dts))
# name the output
for (i in seq_along(out)) {
n = as.character(dts[[i]]) %>% str_replace_all(., "-", "")
names(out)[[i]] = n
}
##----------------------
##  WORK WITH NETCDF  --
##----------------------
# this assumes that the structure of the rainfall data will stay the same
# put the dates into a list as iterating over a vector loses class information..
dts = as.list(dts)
# get one example raster
y = format(dts[[1]], "%Y")
m = format(dts[[1]], "%m")
d = format(dts[[1]], "%d")
# example path
ex_path = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
# example raster
grd = raster(ex_path)[[1]]
grd[] = NA
# if not equal to crs of sf object stop/reproject here!
crs_nc = suppressWarnings(grd %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape = suppressWarnings(crs(spatial.obj) %>% crs() %>% attributes() %>% .[["projargs"]])
# if not equal, reproject the shape...
if(!crs_nc == crs_shape){
warning(sprintf("The CRS of the spatial object and the NetCDF are not equal Reprojecting the shape to: %s", crs_nc))
spatial.obj = st_transform(spatial.obj, crs_nc)
}
# for each day create a dataframe
counter = 1
for (day in dts) {
# create counter
# # where to put the output data
# # length of the list is the size of the spatial object
# out_data = vector("list", length=nrow(spatial.obj))
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
paths_to_data = get_nc_paths(data_path, day, days_back)
message("Accessing these NetCDF-files: ", paths_to_data)
# if all the data we want comes from the same month
if(length(paths_to_data == 1)){
# open the file
ncin = ncdf4::nc_open(paths_to_data[[1]])
# get a character string of the dates
dates_nc = get_dates_ncdf(ncin, return_date_object=T)
raster_list = get_raster_list_one_month(day, days_back, dates_nc, paths_to_data)
} else{
# we need a loop in order to extract them
# if the back days reach into the last month..
# for each month
raster_list = get_raster_list_n_month(paths_to_data, day, days_back)
}
# ectract the spatial data
if(is.null(fun)) {
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, sp = T) %>% st_as_sf()
})
} else{
message("using polygons and the function: ", fun)
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, fun = mean, sp = T) %>% st_as_sf()
})
}
# make in one dataframe where each column is one date
b = bind_cols(day_data_frame)
geom = b %>% dplyr::select(matches("geom")) %>% pull(1)
b = b %>% dplyr::select(matches("^x")) %>%
rename_all(funs(stringr::str_replace_all(., pattern = "X", "")))
b[["geometry"]] = geom
b = st_as_sf(b)
# assign it to out
out[[counter]] = b
counter = counter + 1
}
return(out)
}
devtools::load_all()
shape = st_read("../../../Desktop/bolzano.gpkg")
data_path="\\\\projectdata.eurac.edu/projects/Proslide/PREC_GRIDS/"
dts = c(as.Date("2016-01-12"), as.Date("2016-01-14"))
res = get_rainfall(spatial.obj = shape, dts=dts)
res
mapview::mapview(res[[1]])
warnings()
spatial.obj = shape
crs_shape = suppressWarnings(crs(spatial.obj) %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape
crs_nc
if(!crs_nc == crs_shape){
warning(sprintf("The CRS of the spatial object and the NetCDF are not equal Reprojecting the shape to: %s", crs_nc))
spatial.obj = st_transform(spatial.obj, crs_nc)
}
res = get_rainfall(spatial.obj = shape, dts=dts)
warnings()
?get_rainfall
res
class(res)
devtools::load_all()
?get_rainfall
?get_rainfall
devtools::document()
?get_rainfall
rainfall
file.edit("R/utils.R")
devtools::document()
devtools::document()
warnings()
file.edit("NAMESPACE")
?get_rainfall
