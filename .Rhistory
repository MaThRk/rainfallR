a = as.Date("2020-01-01")
class(a)
?assert_that
devtools::document()
devtools::load_all()
devtools::document()
devtools::document()
devtools::document()
devtools::load_all()
devtools::build()
rainfallR::get_rainfall(data_path = a)
devtools::load_all()
rainfallR::get_rainfall(data_path = a)
data_path="\\\\projectdata.eurac.edu/projects/Proslide/PREC_GRIDS/"
spatial.obj = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_1.shp"
rainfallR::get_rainfall(spatial.obj = spatial.obj)
rainfallR::get_rainfall(spatial.obj = spatial.obj)
devtools::load_all()
rainfallR::get_rainfall()
rainfallR::get_rainfall(data_path = "a")
devtools::load_all()
rainfallR::get_dates()
rainfallR::get_rainfall()
spatial.obj
shape = st_read(spatial.obj)
rainfallR::get_rainfall(spatial.obj = spatial.obj)
rainfallR::get_rainfall(spatial.obj = shape)
dts
dts = as.Date("2020-01-01")
# assert that dates are actually dates
assert_that(is.date(dts), msg = "dts must be an object of type date")
library(assertthat)
# assert that dates are actually dates
assert_that(is.date(dts), msg = "dts must be an object of type date")
rainfallR::get_rainfall(spatial.obj = shape)
dts
class(dts)
# assert that dates are actually dates
assert_that(is.date(dts), msg = "dts must be an object of type date")
# assert that dates are actually dates
assert_that(is.date(dts), msg = "dts must be an object of type date")
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
day = dts[[1]]
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
path_year_month = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
# open the file
ncin = ncdf4::nc_open(path_year_month)
path_year_month
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
dts
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
dts[[1]]
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
for (day in dts) {
print(day)
}
dts = c(as.date("2020-01-01"), as.Date("2021-02-02"))
dts = c(as.Date("2020-01-01"), as.Date("2021-02-02"))
dts
for (day in dts) {
print(day)
}
for (day in dts) {
print(as.Date(day))
}
class(dts[[1]])
pritn(dts[[1]])
print(dts[[1]])
dts
for (day in dts) {
print(as.Date(day))
}
for (day in dts) {
print(day)
}
dts[[1]]
dts = as.list(dts)
dts
for (day in dts) {
print(day)
}
dt = as.Date("2021-01-01")
l = as.list(dt)
l
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
dts
dts = c(as.Date("2020-01-01"), as.Date("2021-02-02"))
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
dts
seqq
dts = as.Date("2020-01-01")
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
days_back = 1
class(days_back)
days_back = 1:1
class(days_back)
days_back
dts = as.Date("2017-01-01")
dts
spatial.obj
shape
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
#' @export
get_rainfall = function(data_path="\\\\projectdata.eurac.edu/projects/Proslide/PREC_GRIDS/",
spatial.obj = NULL,
fun = NULL,
dts = NULL,
seqq = TRUE, # do you want all dates in this sequence or only specific dates?
days_back = 1:1){
# check the inputs are provided at all
if(is.null(data_path)){
stop("You need to provide a path to the netcdf data")
}
if(is.null(spatial.obj)){
stop("You need to provide a spatial object from where to extract the data")
}
# verify its an object of type sf
assert_that(class(spatial.obj)[[1]] == "sf", msg="The spatial data is not of class sf")
# assert that dates are actually dates
assert_that(is.date(dts), msg = "dts must be an object of type date")
# integer range of dates
assert_that(is.integer(days_back), msg = "The date range must be of type integer")
# get the geometry type of the sf object
gtype = st_geometry_type(spatial.obj, by_geometry = FALSE) %>% as.character()
if(!gtype=="POINT"){
gtype="poly"
}  else{
gtype="point"
}
# what kind of dates
if(length(dts) > 1) {
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
n_days = length(dts)
message(paste("Extracting data for a sequential range of", n_days,  "dates"))
message(paste("with", max(days_back), "day(s) in antecedence"))
# output will be a list of datafames
out = vector("list", length = length(dts))
} else{
# only specifc dates
message(paste("Extracting data for", length(dts), "specific dates"))
message(paste("with", max(days_back), "day(s) in antecedence"))
dts = dts
# output will be a list of datafames
out = vector("list", length = length(dts))
}
} else{
# only one specific date
message(paste("Extracting data for one date:", dts, "\n",
"with", max(days_back), "day(s) in antecedence" ))
dts = dts
# output will be only one dataframe
out = data.frame()
}
#### Exract the data from NETCDF
# this assumes that the structure of the rainfall data will stay the same
# put the dates into a list as iterating over a vector loses class information
dts = as.list(dts)
# for each day create a dataframe
for (day in dts) {
print(dts)
print(day)
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
path_year_month = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
# # maybe better to do it this way
# all_files = list.files(paste0(data_path, y))
# file_nc_path = all_files[str_detect(all_files, paste0(y,m))]
# file_nc_path = paste0(data_path, y, "/", file_nc_path)
# nc_open(file_nc_path)
# open the file
ncin = ncdf4::nc_open(path_year_month)
print(ncin)
# get a character string of the dates
#dates_nc = extract_dates(ncin)
}
}
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rm(list=ls())
devtools::load_all()
sessionInfo()
shape = read_sf("\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_1.shp")
dts
dts = as.Date("2017-01-01")
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
data_path="\\\\projectdata.eurac.edu/projects/Proslide/PREC_GRIDS/"
# check the inputs are provided at all
if(is.null(data_path)){
stop("You need to provide a path to the netcdf data")
}
if(is.null(spatial.obj)){
stop("You need to provide a spatial object from where to extract the data")
}
spatial.obj = shape
if(is.null(spatial.obj)){
stop("You need to provide a spatial object from where to extract the data")
}
# verify its an object of type sf
assert_that(class(spatial.obj)[[1]] == "sf", msg="The spatial data is not of class sf")
# assert that dates are actually dates
assert_that(is.date(dts), msg = "dts must be an object of type date")
# integer range of dates
assert_that(is.integer(days_back), msg = "The date range must be of type integer")
days_back = 1:1
# verify its an object of type sf
assert_that(class(spatial.obj)[[1]] == "sf", msg="The spatial data is not of class sf")
# assert that dates are actually dates
assert_that(is.date(dts), msg = "dts must be an object of type date")
# integer range of dates
assert_that(is.integer(days_back), msg = "The date range must be of type integer")
# get the geometry type of the sf object
gtype = st_geometry_type(spatial.obj, by_geometry = FALSE) %>% as.character()
if(!gtype=="POINT"){
gtype="poly"
}  else{
gtype="point"
}
# what kind of dates
if(length(dts) > 1) {
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
n_days = length(dts)
message(paste("Extracting data for a sequential range of", n_days,  "dates"))
message(paste("with", max(days_back), "day(s) in antecedence"))
# output will be a list of datafames
out = vector("list", length = length(dts))
} else{
# only specifc dates
message(paste("Extracting data for", length(dts), "specific dates"))
message(paste("with", max(days_back), "day(s) in antecedence"))
dts = dts
# output will be a list of datafames
out = vector("list", length = length(dts))
}
} else{
# only one specific date
message(paste("Extracting data for one date:", dts, "\n",
"with", max(days_back), "day(s) in antecedence" ))
dts = dts
# output will be only one dataframe
out = data.frame()
}
# put the dates into a list as iterating over a vector loses class information
dts = as.list(dts)
dts
day = dts[[1]]
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
path_year_month = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
path_year_month
# open the file
ncin = ncdf4::nc_open(path_year_month)
ncin
dates = ncdf4::ncvar_get(ncin, "DATE")
dates
dunits = ncdf4::ncatt_get(ncin, "DATE", "units")
dunits
# convert the time variable
tustr = strsplit(dunits$value, " ")
tdstr = strsplit(unlist(tustr)[[3]], "-")
tmonth = as.integer(unlist(tdstr)[[2]])
tday = as.integer(unlist(tdstr)[[3]])
tyear = as.integer(unlist(tdstr)[[1]])
all_dates = chron::chron(dates, origin = c(tmonth, tday, tyear))
all_dates
class(ncin)
devtools::load_all()
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
dts
class(dts)
dts = dts[[1]]
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
library(bannerCommenter)
banner("WORK WITH NETCDF", snug=T, bandChar = "")
banner("WORK WITH NETCDF", snug=T, bandChar = "-")
devtools::load_all()
library(ncdf4.helpers)
st_crs(shape)
# read the precipitation values
precip_nc = ncvar_get(ncin, nc_var)
nc_var = "precipitation"
# read the precipitation values
precip_nc = ncvar_get(ncin, nc_var)
nc_var
precip_nc
dim(precip_nc)
# read the projection info
proj = nc.get.proj4.string(ncin)
# read the projection info
proj = nc.get.proj4.string(ncin, nc_var)
proj
epsgs = rgdal::make_EPSG()
head(epsgs)
epsgs %>% filter(str_detect(prj4, proj))
r("\\")
r"\\zs"
r"{\\zs}"
sprintf(r"%s", proj)
sprintf(r"{%s}", proj)
epsgs %>% filter(str_detect(prj4, sprintf(r"{%s}", proj)))
a = sprintf(r"{%s}", proj)
class(a)
proj
epsgs
dim(epsgs)
proj
t = raster(ncin)
library(raster)
t = raster(ncin)
ncin
raster(path_year_month)
t = raster(path_year_month)[[1]]
crs(t)
st_crs(t)
st_crs(t) == st_crs(shape)
crs(shape)
crs(r)
crs(r)t
crs(t)
shape
st_crs(shape)
crs(shape)
st_crs(shape)
st_crs(t)
crs(shape)
rgdal::showEPSG(proj)
rgdal::showEPSG(st_crs(shape))
s = crs(shape)
rgdal::showEPSG(st_crs(s))
s
class(s)
s = st_crs(shape)
proj4string(shape)
s
s$input
rgdal::showSRID(t)
t
rgdal::showEPSG(t)
crs_ras = crs(t)
crs_ras
class(crs_ras)
rgdal::showEPSG(crs_ras)
raster::crs(r)
r
t
raster::crs(t)
c = raster::crs(t)
c@projargs
rgdal::showEPSG(c@projargs)
rgdal::showEPSG(c)
st_crs(shape)
crs(shape)
a = crs(shape)
a@projargs
rgdal::showEPSG(a@projargs)
crs_nc = raster(path_year_month)[[1]] %>% crs(.)$projargs
crs_nc
raster(path_year_month)[[1]]
a = raster(path_year_month)[[1]]
a %>% crs()
a %>% crs()@projargs
b = a %>% crs()
attributes(b)
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes()
crs_nc
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% [[]]$projargs
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% [[$projargs
crs_shape = raster(path_year_month)[[1]]
stopifnot()
}
}
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% [["projargs"]]
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]]
crs_nc
crs_shape = crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]]
crs_shape
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]]
crs_shape = crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]]
stopifnot()
?stopifnot
# if not equal to crs of sf object stop here!
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]]
crs_nc = raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]]
crs_shape = crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]]
stopifnot("The CRS of the spatial object and the NetCDF are not equal" = crs_nc == crs_shape)
# if not equal to crs of sf object stop here!
crs_nc = suppressWarnings(raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]])
crs_nc = suppressWarnings(raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape = suppressWarnings(crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]])
stopifnot("The CRS of the spatial object and the NetCDF are not equal" = crs_nc == crs_shape)
st_crs(shape)
st_crs(shape) = crs_nc
?st_transform
st_transform(shape, crs_nc)
shape = st_transform(shape, crs_nc)
# if not equal to crs of sf object stop here!
crs_nc = suppressWarnings(raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape = suppressWarnings(crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]])
stopifnot("The CRS of the spatial object and the NetCDF are not equal" = crs_nc == crs_shape)
warning("The CRS of the spatial object and the NetCDF are not equal")
warning("The CRS of the spatial object and the NetCDF are not equal\n")
# if not equal to crs of sf object stop/reproject here!
crs_nc = suppressWarnings(raster(path_year_month)[[1]] %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape = suppressWarnings(crs(shape) %>% crs() %>% attributes() %>% .[["projargs"]])
# if not equal, reproject the shape...
if(!crs_nc == crs_shape){
warning(sprintf("The CRS of the spatial object and the NetCDF are not equal\n
Reprojecting the shape to: %s", crs_nc))
}
shape = st_read(spatial.obj)
spatial.obj
shape = spatial.obj
class(shape)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
devtools::load_all()
rainfallR::get_rainfall(spatial.obj = shape, dts=dts)
shape
s1 = shape[1,]
dim(s1)
s
s1
shape = s1
shape
plot(shape)
class(shape)
plot(shape)
plot(st_geometry(shape))
a = 1:3
a
for (i in a) {
print(i)
}
class(precip_nc)
sessionInfo()
devtools::load_all()
sessionInfo()
file.edit("DESCRIPTION")
usethis::use_package("dplyr")
usethis::use_package("s")
usethis::use_package("sf")
usethis::use_package("raster")
usethis::use_package("cron")
usethis::use_package("chron")
usethis::use_package("ncdf4")
usethis::use_package("ncdf4.helpers")
usethis::use_package("assertthat")
