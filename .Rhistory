# limit to 50 polygons
spatial.obj = read_sf(poly) %>% dplyr::slice_head(n=50)
# better get used to use base R again
spatial.obj = read_sf(poly) %>% .[1:50,]
poly = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_5.shp"
dts = as.Date("2020-01-01")
days_back = 7
spatial.obj = read_sf(poly) %>% dplyr::slice_head(n=50)
spatial.obj = read_sf(poly) %>% .[1:50,]
# get the geometry type of the sf object
gtype = st_geometry_type(spatial.obj, by_geometry = FALSE) %>% as.character()
if(!gtype=="POINT"){
gtype="poly"
}  else{
gtype="point"
}
# if polygon and no function to aggregate the data throw error
if(gtype == "poly" & is.null(fun)){
warning("You can't use polygons and not provide a function to aggreate the data")
print("Setting the aggreation automatically to: 'mean'")
}
fun=mean
# get the geometry type of the sf object
gtype = st_geometry_type(spatial.obj, by_geometry = FALSE) %>% as.character()
if(!gtype=="POINT"){
gtype="poly"
}  else{
gtype="point"
}
gtype
# if polygon and no function to aggregate the data throw error
if(gtype == "poly" & is.null(fun)){
warning("You can't use polygons and not provide a function to aggreate the data")
print("Setting the aggreation automatically to: 'mean'")
}
# for creating a sequence between two dates
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
}
seqq=T
# for creating a sequence between two dates
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
}
dts
# for creating a sequence between two dates
if(length(dts) == 1){
seqq = FALSE
}
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
}
dts
# example path
ex_path = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
data_path="\\\\projectdata.eurac.edu/projects/Proslide/PREC_GRIDS/"
# example path
ex_path = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
# get one example raster
y = format(dts[[1]], "%Y")
m = format(dts[[1]], "%m")
d = format(dts[[1]], "%d")
# example path
ex_path = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
ex_path
file.exists(ex_path)
devtools::document()
file.edit("R/get_raster_list_one_month.R")
file.edit("NAMESPACE")
devtools::document()
file.edit("R/utils.R")
devtools::document()
devtools::load_all()
# the path to the directory of the NetCDFs which are stored for each month
path_ncdf = "\\\\projectdata.eurac.edu/projects/Proslide/PREC_GRIDS/"
# path to spatial data
poly = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_5.shp"
dts = as.Date("2018-01-01")
days_back = 7
# limit to 50 polygons
spatial.obj = read_sf(poly) %>% dplyr::slice_head(n=50)
# better get used to use base R again
spatial.obj = read_sf(poly) %>% .[1:50,]
# get the geometry type of the sf object
gtype = st_geometry_type(spatial.obj, by_geometry = FALSE) %>% as.character()
if(!gtype=="POINT"){
gtype="poly"
}  else{
gtype="point"
}
gtype
# if polygon and no function to aggregate the data throw error
if(gtype == "poly" & is.null(fun)){
warning("You can't use polygons and not provide a function to aggreate the data")
print("Setting the aggreation automatically to: 'mean'")
}
# for creating a sequence between two dates
if(length(dts) == 1){
seqq = FALSE
}
if (seqq) {
dts = seq(dts[[1]], dts[[2]], by = "day")
}
# output will be a list of datafames
out = vector("list", length = length(dts))
out
# name the output
for (i in seq_along(out)) {
n = as.character(dts[[i]]) %>% str_replace_all(., "-", "")
names(out)[[i]] = n
}
file.edit("NAMESPACE")
devtools::document()
devtools::load_all()
# name the output
for (i in seq_along(out)) {
n = as.character(dts[[i]]) %>% str_replace_all(., "-", "")
names(out)[[i]] = n
}
##----------------------
##  WORK WITH NETCDF  --
##----------------------
# this assumes that the structure of the rainfall data will stay the same
# put the dates into a list as iterating over a vector loses class information..
dts = as.list(dts)
# get one example raster
y = format(dts[[1]], "%Y")
m = format(dts[[1]], "%m")
d = format(dts[[1]], "%d")
# example path
ex_path = paste0(data_path, y, "/", "DAILYPCP_", y, formatC(m, flag = 0, width = 2), ".nc")
# if not path exists --> there is no nc file for this path
if(!file.exists(ex_path)){
stop("No file foud. Maybe you used days that are not available...")
}
# example raster
grd = raster(ex_path)[[1]]
grd[] = NA
# if not equal to crs of sf object stop/reproject here!
crs_nc = suppressWarnings(grd %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape = suppressWarnings(crs(spatial.obj) %>% crs() %>% attributes() %>% .[["projargs"]])
# if not equal, reproject the shape...
if(!crs_nc == crs_shape){
warning(sprintf("The CRS of the spatial object and the NetCDF are not equal Reprojecting the shape to: %s", crs_nc))
spatial.obj = st_transform(spatial.obj, crs_nc)
}
# example raster
grd = raster(ex_path)[[1]]
grd
grd[] = NA
# if not equal to crs of sf object stop/reproject here!
crs_nc = suppressWarnings(grd %>% crs() %>% attributes() %>% .[["projargs"]])
library(raster)
# if not equal to crs of sf object stop/reproject here!
crs_nc = suppressWarnings(grd %>% crs() %>% attributes() %>% .[["projargs"]])
crs_shape = suppressWarnings(crs(spatial.obj) %>% crs() %>% attributes() %>% .[["projargs"]])
# if not equal, reproject the shape...
if(!crs_nc == crs_shape){
warning(sprintf("The CRS of the spatial object and the NetCDF are not equal Reprojecting the shape to: %s", crs_nc))
spatial.obj = st_transform(spatial.obj, crs_nc)
}
for (day in dts) {
# create counter
# # where to put the output data
# # length of the list is the size of the spatial object
# out_data = vector("list", length=nrow(spatial.obj))
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
paths_to_data = get_nc_paths(data_path, day, days_back)
message("Accessing these NetCDF-files: ", paths_to_data)
# if all the data we want comes from the same month
if(length(paths_to_data == 1)){
# open the file
ncin = ncdf4::nc_open(paths_to_data[[1]])
# get a character string of the dates
dates_nc = get_dates_ncdf(ncin, return_date_object=T)
raster_list = get_raster_list_one_month(day, days_back, dates_nc, paths_to_data)
} else{
# we need a loop in order to extract them
# if the back days reach into the last month..
# for each month
raster_list = get_raster_list_n_month(paths_to_data, day, days_back)
}
# ectract the spatial data
if(is.null(fun)) {
print("Input are points, thus not using any function")
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, sp = T) %>% st_as_sf()
})
} else{
message("using polygons and the function: ", fun@generic[[1]])
day_data_frame = lapply(raster_list, function(x) {
print(paste0("Extracting data for: ", names(x)))
raster::extract(x, spatial.obj, fun = fun, sp = T) %>% st_as_sf()
})
}
# make in one dataframe where each column is one date
b = dplyr::bind_cols(day_data_frame)
geom = b %>% dplyr::select(matches("geom")) %>% pull(1)
b = b %>% dplyr::select(matches("^x")) %>%
dplyr::rename_all(funs(stringr::str_replace_all(., pattern = "X", "")))
b[["geometry"]] = geom
b = st_as_sf(b)
# assign it to out
out[[counter]] = b
counter = counter + 1
}
counter = 1
for (day in dts) {
# create counter
# # where to put the output data
# # length of the list is the size of the spatial object
# out_data = vector("list", length=nrow(spatial.obj))
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
# create the path to the data for one month
paths_to_data = get_nc_paths(data_path, day, days_back)
message("Accessing these NetCDF-files: ", paths_to_data)
# if all the data we want comes from the same month
if(length(paths_to_data == 1)){
# open the file
ncin = ncdf4::nc_open(paths_to_data[[1]])
# get a character string of the dates
dates_nc = get_dates_ncdf(ncin, return_date_object=T)
raster_list = get_raster_list_one_month(day, days_back, dates_nc, paths_to_data)
} else{
# we need a loop in order to extract them
# if the back days reach into the last month..
# for each month
raster_list = get_raster_list_n_month(paths_to_data, day, days_back)
}
# ectract the spatial data
if(is.null(fun)) {
print("Input are points, thus not using any function")
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, sp = T) %>% st_as_sf()
})
} else{
message("using polygons and the function: ", fun@generic[[1]])
day_data_frame = lapply(raster_list, function(x) {
print(paste0("Extracting data for: ", names(x)))
raster::extract(x, spatial.obj, fun = fun, sp = T) %>% st_as_sf()
})
}
# make in one dataframe where each column is one date
b = dplyr::bind_cols(day_data_frame)
geom = b %>% dplyr::select(matches("geom")) %>% pull(1)
b = b %>% dplyr::select(matches("^x")) %>%
dplyr::rename_all(funs(stringr::str_replace_all(., pattern = "X", "")))
b[["geometry"]] = geom
b = st_as_sf(b)
# assign it to out
out[[counter]] = b
counter = counter + 1
}
day = dts[[1]]
# get the year the month and the day
y = format(day, "%Y")
m = format(day, "%m")
d = format(day, "%d")
y
m
d
# create the path to the data for one month
paths_to_data = get_nc_paths(data_path, day, days_back)
paths_to_data
message("Accessing these NetCDF-files: ", paths_to_data)
cat("Accessing these NetCDF-files: ", paths_to_data)
cat(paste0("Accessing these NetCDF-files: ", paths_to_data))
message("Accessing these NetCDF-files: ", paths_to_data)
# open the file
ncin = ncdf4::nc_open(paths_to_data[[1]])
dates_nc = get_dates_ncdf(ncin, return_date_object=T)
dates_nc
raster_list = get_raster_list_one_month(day, days_back, dates_nc, paths_to_data)
raster_list
fun
fun=mean
# ectract the spatial data
if(is.null(fun)) {
print("Input are points, thus not using any function")
day_data_frame = lapply(raster_list, function(x) {
raster::extract(x, spatial.obj, sp = T) %>% st_as_sf()
})
} else{
message("using polygons and the function: ", fun@generic[[1]])
day_data_frame = lapply(raster_list, function(x) {
print(paste0("Extracting data for: ", names(x)))
raster::extract(x, spatial.obj, fun = fun, sp = T) %>% st_as_sf()
})
}
b = dplyr::bind_cols(day_data_frame)
b
geom = b %>% dplyr::select(matches("geom")) %>% pull(1)
b = b %>% dplyr::select(matches("^x")) %>%
dplyr::rename_all(funs(stringr::str_replace_all(., pattern = "X", "")))
b = b %>% dplyr::select(matches("^x"))
b
head(b)
b = b %>% dplyr::select(matches("^x")) %>%
dplyr::rename_all(.funs = list(stringr::str_replace_all(., pattern = "X", "")))
# make in one dataframe where each column is one date
b = dplyr::bind_cols(day_data_frame)
geom = b %>% dplyr::select(matches("geom")) %>% pull(1)
b = b %>% dplyr::select(matches("^x")) %>%
dplyr::rename_all(.funs = list(stringr::str_replace_all(., pattern = "X", "")))
# make in one dataframe where each column is one date
b = dplyr::bind_cols(day_data_frame)
geom = b %>% dplyr::select(matches("geom")) %>% pull(1)
b = b %>% dplyr::select(matches("^x")) %>%
dplyr::rename_with(., ~stringr::str_replace_all(., pattern = "X", ""))
b
head(b)
b[["geometry"]] = geom
b
head(b)
b = st_as_sf(b)
a = "X20171225"
a %>% substr(., start=2, stop=nchar(.))
a %>% substr(., start=2, stop=nchar(.)) %>% as.Date(., "%Y%m%d")
a
stringr::str_match(a, "X")
stringr::str_match(a, "X(\\d{2}")
stringr::str_match(a, "X(\\d{2})")
stringr::str_match(a, "X(\\d{2})(.*)")
stringr::str_match(a, "X(\\d{2})(.*)")
a
a = c(a,a)
a
stringr::str_match(a, "X(\\d{2})(.*)")
stringr::str_match_all(a, "X(\\d{2})(.*)")
file.edit("R/get_cumulatitve_rainfall.R")
res = load("../../../Desktop/test.RData")
res
load("../../../Desktop/test.RData")
res
#' Reshape the dataframe and create cumulative count column
#'
#' @importFrom tidyr pivot_longer
#'
#' @param res an object as retured from `get_rainfall`
#'
#' @return a list of `dataframes` for each date with the cumulative amount for each day as column and the dates as another column.
#'
#' @export
get_cumulative_rainfall = function(res, cumsum=T){
# the output list
out = vector("list", length=length(res))
names(out) = names(res)
# for each element in the res list, get the dataframe
for (i in seq_along(res)) {
df = res[[i]]
# get the geometry column
geom = df %>% st_geometry()
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d")) %>%
# get the cumulative count for the days
mutate(accumulated = cumsum(precip)) %>%
mutate(geom = geom) %>%
st_as_sf()
# put back in the output list
out[[i]] = df_long
}
return(out)
}
get_cumulative_rainfall(res)
# the output list
out = vector("list", length=length(res))
ouit
ouit
out
names(out) = names(res)
out
i=1
df = res[[i]]
df
geom = df %>% st_geometry()
geom
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d")) %>%
# get the cumulative count for the days
mutate(accumulated = cumsum(precip)) %>%
mutate(geom = geom) %>%
st_as_sf()
df_long = df %>%
st_drop_geometry()
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip")
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d"))
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d")) %>%
# get the cumulative count for the days
mutate(accumulated = cumsum(precip))
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d")) %>%
# get the cumulative count for the days
mutate(accumulated = cumsum(precip)) %>%
mutate(geom = geom)
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d")) %>%
# get the cumulative count for the days
mutate(accumulated = cumsum(precip))
dim(df_long)
df_long = df %>%
st_drop_geometry()
dim(df_long)
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip")
df_long
df
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip")
df_long
df_long = df %>%
# st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip")
pivot_longer(cols = everything(), names_to="dates", values_to="precip")df
df
t = res[1,]
res
class(res)
df
t = df[1,]
df = df[1,]
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d")) %>%
# get the cumulative count for the days
mutate(accumulated = cumsum(precip)) %>%
mutate(geom = geom) %>%
st_as_sf()
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip")
df_long
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d"))
df_long
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d")) %>%
# get the cumulative count for the days
mutate(accumulated = cumsum(precip))
df_long
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d")) %>%
# get the cumulative count for the days
mutate(accumulated = cumsum(precip)) %>%
mutate(geom = geom) %>%
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d")) %>%
# get the cumulative count for the days
mutate(accumulated = cumsum(precip)) %>%
mutate(geom = geom)
geom
# get the geometry column
geom = df %>% st_geometry()
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d")) %>%
# get the cumulative count for the days
mutate(accumulated = cumsum(precip)) %>%
mutate(geom = geom)
df_long = df %>%
st_drop_geometry() %>%
pivot_longer(cols = everything(), names_to="dates", values_to="precip") %>%
mutate(dates = as.Date(dates, "%Y%m%d")) %>%
# get the cumulative count for the days
mutate(accumulated = cumsum(precip)) %>%
mutate(geom = geom) %>%
st_as_sf()
df_long
df_long[,-c(geom)]
df_long[,-c("geom")]
df_long[,c(-"geom")]
df_long[,c(1:3)]
df_long[,c(1:2)]
df %>% st_drop_geometry()
df
df_long
df_long %>% st_drop_geometry()
res
